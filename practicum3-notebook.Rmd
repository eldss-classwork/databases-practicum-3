---
title: 'CS5200 Fall 2020: Practicum 3'
author: "Chandra Davis, Evan Douglass"
output:
  pdf_document: default
  word_document: default
  html_document:
    df_print: paged
---

## Overview

We've decided to work with SQLite for this practicum. As such, to work with these files you will need SQLite installed on your machine. The data we are using was provided with the practicum

```{r}
# Libraries needed for processing
library(RSQLite)
library("XML")
library(dplyr)
library(tibble)
```


## Part 1
Create a normalized relational OLTP database and populate it with data from an XML document.

### Task 1
Create a normalized relational schema that contains minimally the following entities: Article, Journal, Author, History. Use the XML document to determine the appropriate attributes (fields/columns) for the entities (tables). While there may be other types of publications in the XML, you only need to deal with articles in journals. Create appropriate primary and foreign keys. Where necessary, add surrogate keys. Include an image of an ERD showing your model in your R Notebook.

Lucidchart link: 

![Task1.1](imgs/OriginalTables.png)

### Task 2
Realize the relational schema in SQLite (place the CREATE TABLE statements into SQL chunks in your R Notebook).

```{r}
DB_NAME <- "pubMed.db"

conn <- dbConnect(RSQLite::SQLite(), DB_NAME)
```


```{r}
# Since the dataset is small, the database should be re-created at runtime
drop_table <- function(table_name) {
    paste("DROP TABLE IF EXISTS ", table_name, ";", sep="")
}

# Since we are dropping all tables, disable the FK checks
dbExecute(conn, "PRAGMA foreign_keys = OFF;")
# Get a list of all tables currently in the database
table_list <- dbListTables(conn)
# Drop every table in the database
for(table in table_list){
  dbExecute(conn, drop_table(table))
}
```

```{sql connection=conn}
PRAGMA foreign_keys = ON;
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS ELocType (
  eType_id INTEGER PRIMARY KEY AUTOINCREMENT,
  eType TEXT NOT NULL,
  CONSTRAINT unique_eLocType_eType UNIQUE (eType)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS CategoryLabels (
  label_id INTEGER PRIMARY KEY AUTOINCREMENT,
  label TEXT NOT NULL,
  CONSTRAINT unique_catLab_label UNIQUE (label)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Affiliations (
  aff_id INTEGER PRIMARY KEY AUTOINCREMENT,
  aff TEXT NOT NULL,
  CONSTRAINT unique_aff_aff UNIQUE (aff)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Pagination (
  pgn_id INTEGER PRIMARY KEY AUTOINCREMENT,
  medlinePgn TEXT NOT NULL,
  CONSTRAINT unique_pgn_medpgn UNIQUE (medlinePgn)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Languages (
  lang_id INTEGER PRIMARY KEY AUTOINCREMENT,
  language TEXT NOT NULL,
  CONSTRAINT unique_lang_lang UNIQUE (language)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS IsoAbbreviation (
  abbr_id INTEGER PRIMARY KEY AUTOINCREMENT,
  abbr TEXT NOT NULL,
  CONSTRAINT unique_isoAbbr_abbr UNIQUE (abbr)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS MediumType (
  medium_id INTEGER PRIMARY KEY AUTOINCREMENT,
  medium TEXT NOT NULL,
  CONSTRAINT unique_med_med UNIQUE (medium)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Countries (
  country_id INTEGER PRIMARY KEY AUTOINCREMENT,
  country TEXT NOT NULL,
  CONSTRAINT unique_country_country UNIQUE (country)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Agencies (
  agency_id INTEGER PRIMARY KEY AUTOINCREMENT,
  agency TEXT NOT NULL,
  CONSTRAINT unique_agency_agency UNIQUE (agency)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Acronyms (
  acronym_id INTEGER PRIMARY KEY AUTOINCREMENT,
  acronym TEXT NOT NULL,
  CONSTRAINT unique_acr_acr UNIQUE (acronym)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS PublicationType (
  pubType_id INTEGER PRIMARY KEY AUTOINCREMENT,
  pubType TEXT NOT NULL,
  CONSTRAINT unique_pubType_pubType UNIQUE (pubType)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS PubStatus (
  status_id INTEGER PRIMARY KEY AUTOINCREMENT,
  status TEXT NOT NULL,
  CONSTRAINT unique_pubStatus_status UNIQUE (status)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Date (
  date_id INTEGER PRIMARY KEY AUTOINCREMENT,
  year INTEGER NOT NULL,
  month INTEGER NOT NULL,
  day INTEGER NOT NULL,
  CONSTRAINT unique_date_yymmdd UNIQUE (year, month, day)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS ArticleDate (
  artDate_id INTEGER PRIMARY KEY AUTOINCREMENT,
  dateType INTEGER NOT NULL,
  date_id INTEGER NOT NULL,
  CONSTRAINT unique_artdate_typedate UNIQUE (dateType, date_id),
  FOREIGN KEY (dateType) REFERENCES MediumType(medium_id),
  FOREIGN KEY (date_id) REFERENCES Date(date_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Article (
  article_id INTEGER PRIMARY KEY AUTOINCREMENT,
  pubModel INTEGER NOT NULL,
  title Text NOT NULL,
  pgn_id INTEGER NOT NULL,
  authorListComplete BOOLEAN NOT NULL,
  lang_id INTEGER NOT NULL,
  grantListComplete BOOLEAN,
  artDate_id INTEGER,
  FOREIGN KEY (pubModel) REFERENCES MediumType(medium_id),
  FOREIGN KEY (pgn_id) REFERENCES Pagination(pgn_id),
  FOREIGN KEY (lang_id) REFERENCES Languages(lang_id),
  FOREIGN KEY (artDate_id) REFERENCES ArticleDate(artDate_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS PubTypeList (
  pubList_id INTEGER PRIMARY KEY AUTOINCREMENT,
  pubType_id INTEGER NOT NULL,
  article_id INTEGER NOT NULL,
  FOREIGN KEY (pubType_id) REFERENCES PublicationType(pubType_id),
  FOREIGN KEY (article_id) REFERENCES Article(article_id),
  CONSTRAINT unique_pubTypeList_type_art UNIQUE (pubType_id, article_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS ELocationID (
  eLoc_id INTEGER PRIMARY KEY AUTOINCREMENT,
  eType_id INTEGER NOT NULL,
  valid BOOLEAN NOT NULL,
  value Text NOT NULL,
  FOREIGN KEY (eType_id) REFERENCES ELocType(eType_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS ELocList (
  elList_id INTEGER PRIMARY KEY AUTOINCREMENT,
  eLoc_id INTEGER NOT NULL,
  article_id INTEGER NOT NULL,
  FOREIGN KEY (eLoc_id) REFERENCES ELocationID(eLoc_id),
  FOREIGN KEY (article_id) REFERENCES Article(article_id),
  CONSTRAINT unique_eloclist_eLoc_art UNIQUE (eLoc_id, article_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS PubDate (
  pubDate_id INTEGER PRIMARY KEY AUTOINCREMENT,
  medlineDate BOOLEAN NOT NULL,
  dateYYMM Text NOT NULL,
  CONSTRAINT unique_pubDate_med_date UNIQUE (medlineDate, dateYYMM)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS JournalIssue (
  issue_id INTEGER PRIMARY KEY AUTOINCREMENT,
  volume INTEGER NOT NULL,
  issue INTEGER NOT NULL,
  citedMedium INTEGER NOT NULL,
  pubDate_id INTEGER NOT NULL,
  FOREIGN KEY (citedMedium) REFERENCES MediumType(medium_id),
  FOREIGN KEY (pubDate_id) REFERENCES PubDate(pubDate_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS ArticleList (
  artList_id INTEGER PRIMARY KEY AUTOINCREMENT,
  issue_id INTEGER NOT NULL,
  article_id INTEGER NOT NULL,
  FOREIGN KEY (issue_id) REFERENCES JournalIssue(issue_id),
  FOREIGN KEY (article_id) REFERENCES Article(article_id),
  CONSTRAINT unique_artlist_issue_art UNIQUE (issue_id, article_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS ISSN (
  issn_id INTEGER PRIMARY KEY AUTOINCREMENT,
  issnType INTEGER NOT NULL,
  value Text NOT NULL,
  CONSTRAINT unique_issn_typeissn UNIQUE (dateType, value),
  FOREIGN KEY (dateType) REFERENCES MediumType(medium_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Journal (
  journal_id INTEGER PRIMARY KEY AUTOINCREMENT,
  title Text NOT NULL,
  issn_id INTEGER NOT NULL,
  isoAbbr INTEGER NOT NULL,
  FOREIGN KEY (issn_id) REFERENCES ISSN(issn_id),
  FOREIGN KEY (isoAbbr) REFERENCES IsoAbbreviation(abbr_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS IssueList (
  issueList_id INTEGER PRIMARY KEY AUTOINCREMENT,
  issue_id INTEGER NOT NULL,
  journal_id INTEGER NOT NULL,
  FOREIGN KEY (issue_id) REFERENCES JournalIssue(issue_id),
  FOREIGN KEY (journal_id) REFERENCES Journal(journal_id),
  CONSTRAINT unique_issuelist_issue_jornal UNIQUE (issue_id, journal_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS AbstractText (
  abText_id INTEGER PRIMARY KEY AUTOINCREMENT,
  abText Text NOT NULL,
  label INTEGER,
  nlmCategory INTEGER,
  FOREIGN KEY (label) REFERENCES CategoryLabels(label_id),
  FOREIGN KEY (nlmCategory) REFERENCES CategoryLabels(label_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS AbstractList (
  abList_id INTEGER PRIMARY KEY AUTOINCREMENT,
  abText_id INTEGER NOT NULL,
  article_id INTEGER NOT NULL,
  FOREIGN KEY (abText_id) REFERENCES AbstractText(abText_id),
  FOREIGN KEY (article_id) REFERENCES Article(article_id),
  CONSTRAINT unique_ablist_abstract_art UNIQUE (abText_id, article_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Authors (
  author_id INTEGER PRIMARY KEY AUTOINCREMENT,
  valid BOOLEAN NOT NULL,
  lName Text NOT NULL,
  fName Text NOT NULL,
  initials Text NOT NULL,
  aff_id INTEGER,
  FOREIGN KEY (aff_id) REFERENCES Affiliations(aff_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS AuthorList (
  authList_id INTEGER PRIMARY KEY AUTOINCREMENT,
  author_id INTEGER NOT NULL,
  article_id INTEGER NOT NULL,
  FOREIGN KEY (author_id) REFERENCES Authors(author_id),
  FOREIGN KEY (article_id) REFERENCES Article(article_id),
  CONSTRAINT unique_authlist_author_art UNIQUE (author_id, article_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS Grants (
  grant_id INTEGER PRIMARY KEY AUTOINCREMENT,
  grantID Text NOT NULL,
  acronym_id INTEGER,
  agency_id INTEGER NOT NULL,
  country_id INTEGER NOT NULL,
  FOREIGN KEY (acronym_id) REFERENCES Acronyms(acronym_id),
  FOREIGN KEY (agency_id) REFERENCES Agencies(agency_id),
  FOREIGN KEY (country_id) REFERENCES Countries(country_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS GrantList (
  grantList_id INTEGER PRIMARY KEY AUTOINCREMENT,
  grant_id INTEGER NOT NULL,
  article_id INTEGER NOT NULL,
  FOREIGN KEY (grant_id) REFERENCES Grants(grant_id),
  FOREIGN KEY (article_id) REFERENCES Article(article_id),
  CONSTRAINT unique_grantlist_grant_art UNIQUE (abText_id, article_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS PubMedDate (
  pubMedDate_id INTEGER PRIMARY KEY AUTOINCREMENT,
  status INTEGER NOT NULL,
  date INTEGER NOT NULL,
  hour INTEGER,
  minute INTEGER,
  FOREIGN KEY (status) REFERENCES PubStatus(status_id),
  FOREIGN KEY (date) REFERENCES Date(date_id)
);
```


```{sql connection=conn}
CREATE TABLE IF NOT EXISTS History (
  history_id INTEGER PRIMARY KEY AUTOINCREMENT,
  pubMedDate_id INTEGER NOT NULL,
  article_id INTEGER NOT NULL,
  FOREIGN KEY (pubMedDate_id) REFERENCES AbstractText(pubMedDate_id),
  FOREIGN KEY (article_id) REFERENCES Article(article_id),
  CONSTRAINT unique_history_date_art UNIQUE (pubMedDate_id, article_id)
);
```





### Task 3
Extract and transform the data from the XML and then load into the appropriate tables in the database. You cannot use xmlToDataFrame but instead must parse the XML node by node using a combination of node-by-node tree traversal and XPath. It is not feasible to use XPath to extract all journals, then all authors, etc. as some are missing and won't match up. You will need to iterate through the top-level nodes.

```{r}
# Read the XML file into memory
file <- xmlParse(file = "pubmed_sample.xml")

# Get the first node
root <- xmlRoot(file)
```

```{r}
# Categorical tables need to be unique so do not need to go node by node
# There are 12 categorical attribute tables
# Created function for duplicate processing

getVector <- function(path, att){
  # Grab all of the unique genres
  if(att){
    values <- unique(xpathSApply(file, path))
  } 
  else{
    values <- unique(xpathSApply(file, path, xmlValue))
  }
  
  return(values)
}

catTable <- function(path, tablename, att, mult=FALSE){
  # A few of the categorical tables are made of multiple XML elements/attributes
  if(mult){
    values <- c()
    split <- unlist(strsplit(path, ","))
    for(i in split){
      values <- append(values,getVector(i,att))
    }
    values <- unique(values)
  }
  else {
    values <- getVector(path, att)
  }
  
  # Turn into a dataframe and add unique ids
  df_table <- data.frame(values)
  df_table <- tibble::rowid_to_column(df_table, "id")
  
  # Update column names to match table
  names <- dbGetQuery(conn, 
                      paste("pragma table_info(",tablename,")",sep=""))[["name"]]
  colnames(df_table) <- names
  
  # Put in database
  # Append=TRUE is the preferred method because we want to maintain the referential integrity relationships from table creation
  dbWriteTable(conn, tablename, df_table, append=TRUE)
  
  # Return the dataframe for processing FK relationships
  return(df_table)
}
```

```{r}
# Call function to build all twelve tables
# Save the dataframes for look-up in other tables
df_aff <- catTable("//Affiliation", "Affiliations", FALSE)
df_pgn <- catTable("//MedlinePgn", "Pagination", FALSE)
df_lang <- catTable("//Language", "Languages", FALSE)
df_iso <- catTable("//ISOAbbreviation", "IsoAbbreviation", FALSE)
df_pubType <- catTable("//PublicationType", "PublicationType", FALSE)
df_country <- catTable("//Country", "Countries", FALSE)
df_agency <- catTable("//Agency", "Agencies", FALSE)
df_acr <- catTable("//Acronym", "Acronyms", FALSE)
df_eIdType <- catTable("//@EIdType", "ELocType", TRUE)
df_pubStatus <- catTable("//@PubStatus", "PubStatus", TRUE)
df_labels <- catTable("//@Label,//@NlmCategory", "CategoryLabels", TRUE, TRUE)
df_mediums <- catTable("//@IssnType,//@CitedMedium,//@PubModel,//@DateType",
                       "MediumType", TRUE, TRUE)
```




## Part 2
Add to the normalized schema fact tables and turn the normalized schema into a de-normalized schema suitable for OLAP.

### Task 1
Create and populate a star schema with dimension and transaction fact tables. Each row in the fact table will represent one article. Include the image of an updated ERD that contains the fact table and any additional required dimension tables. Populate the star schema in R.

Lucidchart link: 

![Task2.1](imgs/OriginalTables.png)

```{r}

```


### Task 2
In the same schema as the previous step, create and populate a summary fact table that represents number of articles per time period (quarter, year) by author and by journal. Include the image of an updated ERD that contains the fact table. Populate the fact table in R.

Lucidchart link: 

![Task2.2](imgs/OriginalTables.png)

```{r}

```


## Part 3
Use the OLAP star schema to do some (simple) data mining.

### Task 1
Write queries using your data warehouse to explore whether the publications show a seasonal pattern. Look beyond the pattern of number of publications per season. Adjust your fact tables as needed to support your new queries. If you need to update the fact table, document your changes and your reasons why the changes are needed.

```{r}

```


### Task 2
Either (a) visualize (graph/plot) the data from the previous step using R to explore seasonality and explain what you found, or (b) build a predictive model to forecast the expected number of publications for a quarter. (Note that we do not cover predictive modeling in this course, so if you do not know this from a prior course, then simply create the visualization.)

```{r}

```


